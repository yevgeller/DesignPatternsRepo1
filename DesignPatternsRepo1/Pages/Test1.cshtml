@page
@model DesignPatternsRepo1.Pages.Test1Model
@{
}


<div id="div1">Testing Shmesting</div>

<div id="tbl"></div>
<br />
<br />
<table>
    <tr><td>1-1</td><td>1-2</td></tr>
    <tr><td>2-1</td><td>2-2</td></tr>
</table>

<script>
    const FIELDWIDTH = 10;
    const FIELDHEIGHT = 10;
    const MINECOUNT = 3;
    const field = Array.from(Array(FIELDHEIGHT), () => new Array(FIELDWIDTH).fill('.'));
    const MINEMARKER = 'X';
    let revealedCellsCount = 0;

    let toProcess = [];

    class Cell {
        constructor(row, col) {
            this.row = row;
            this.col = col;
        }
    }

    document.addEventListener("DOMContentLoaded", function () {
        createField();
        calculateMarkers();
        createTable();
        document.querySelectorAll('#field td').forEach(el => el.addEventListener('click', clickCell));
    });

    function clickCell(el) {
        let hidden = el.currentTarget.getAttribute('data-hidden');
        if (hidden == '0') {
            return;
        }
        revealCell(el.currentTarget);
    }

    function revealCell(el) {
        revealedCellsCount++;
        let row = el.getAttribute('data-row');
        let col = el.getAttribute('data-col');
        //console.log('row-col:', row + ' - ' + col);
        let data = getCellData(row, col);
        el.innerText = data;
        el.style.backgroundColor = "yellow";
        el.style.color = "black";
        el.setAttribute('data-hidden', 0);
        if (data === 'X') {
            gameOver(false);
        } else if (data === '.') {
            let surroundingUnrevealedCells = getSurroundingCells(row, col);
            toProcess.push(...surroundingUnrevealedCells);
            console.log(toProcess);
            //processCells();
            processCells2(surroundingUnrevealedCells);
        } else if(revealedCellsCount + MINECOUNT === FIELDHEIGHT * FIELDWIDTH) {
            gameOver(true);
        }
    }

    function getCellData(row, col) {
        //console.log('checking row:' + row + ' col: ' + col);
        return field[row][col];
    }

    function getSurroundingCells(rowStr, colStr) {
        let interimResult = [];
        let row = Number(rowStr);
        let col = Number(colStr);
        let firstRow = row === 0;
        let firstCol = col === 0;
        let lastRow = row === (field.length - 1);
        let lastCol = col === (field[row].length - 1);
        let midRow = !firstRow && (row < field.length - 1);
        let midCol = !firstCol && (col < field[row].length - 1);

        if (midRow && midCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row - 1, col - 1)); //NW
        } else if (midRow && firstCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
        } else if (midRow && lastCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col - 1)); //NW
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row + 1, col)); //S
        } else if (firstRow && midCol) {
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row, col - 1)); //W
        } else if (lastRow && midCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row - 1, col - 1)); //NW
        } else if (firstRow && firstCol) { //top left
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
        } else if (firstRow && lastCol) { //top right
            interimResult.push(new Cell(row + 1, col)); //S
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row, col - 1)); //W
        } else if (lastRow && firstCol) { //bottom left
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
        } else if (lastRow && lastCol) { //bottom right
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row - 1, col - 1)); //NW
        } else {
            alert('should not be here, row: ' + row + ', col: ' + col);
        }

        let result = [];

        interimResult.forEach(x => {
            let cell = getCell(x);
            if (cell) {
                let ishidden = this.isHidden(cell);
                let alreadyIn = alreadyInQueue(x);
                if (ishidden && !alreadyIn)
                    result.push(x);
                //else
                //    console.log('cell ' + x.row + '-' + x.col + ' is already revealed.');
                //console.log(cell);
            } else console.log('Cell not found with coordinates: ', x.row, x.col);
        });
        let j = result.length;
        return result;
    }

    function getCell(x) {
        return document.querySelector('[data-cell="cell-' + x.row + '-' + x.col + '"]');
    }

    function alreadyInQueue(cell) {
        if (toProcess.some(x => x.row === cell.row && x.col === cell.col)) {
            return true;
        }
        return false;
    }

    //function processCells() {
    //    if (toProcess.length === 0) return;
    //    while (toProcess.length > 0) {
    //        debugger;
    //        let first = toProcess.shift();
    //        if (first && first.hasOwnProperty('row')) {
    //            let data = getCellData(first.row, first.col);
    //            let cell = getCell(first);
    //            revealCell(cell);
    //            if (data === '.') {
    //                toProcess.push(getSurroundingCells(first.row, first.col));
    //            }
    //        }
    //    }
    //}

    function processCells2(cells) {
        debugger;
        //if (cells.length === 0) return;
        while (cells.length > 0) {
            let first = cells.shift();
            //if (first && first.hasOwnProperty('row')) {
                let data = getCellData(first.row, first.col);
                let cell = getCell(first);
                revealCell(cell);
                if (data === '.') {
                    processCells2(getSurroundingCells(first.row, first.col));
                }
            //}
        }
    }

    function isHidden(el) {
        let data = el.getAttribute('data-hidden');
        if (!data) return false;
        if (data == '1') return true;

        return false;
    }

    function setRevealed(el) {
        el.setAttribute('data-hidden', 0);
    }

    function gameOver(win) {
        console.error('game over! Refresh page to start again.');
        document.querySelectorAll('#field td').forEach(el => {
            el.removeEventListener('click', clickCell);
            if (el.innerText === 'X')
                el.style.backgroundColor = (win ? "green" : "red");
        });
    }

    function createField() {
        let mineCount = MINECOUNT;

        while (mineCount > 0) {
            rndRow = randomNumber();
            rndCol = randomNumber();
            if (field[rndRow][rndCol] !== MINEMARKER) {
                field[rndRow][rndCol] = MINEMARKER;
                mineCount--;
            }
        }
        console.log(field);
    }

    function calculateMarkers() {
        for (let i = 0; i < field.length; i++) {
            for (let j = 0; j < field[i].length; j++) {
                if (field[i][j] === MINEMARKER) continue;
                let marker = calcFieldMarker(i, j);
                if (marker > 0) {
                    field[i][j] = marker.toString();
                }
            }
        }
        console.log(field);
    }

    function calcFieldMarker(row, col) {
        let n = calcN(row, col);
        let ne = calcNE(row, col);
        let e = calcE(row, col);
        let se = calcSE(row, col);
        let s = calcS(row, col);
        let sw = calcSW(row, col);
        let w = calcW(row, col);
        let nw = calcNW(row, col);
        return n + ne + e + se + s + sw + w + nw;
    }

    function calcN(row, col) {
        if (row === 0) return 0;
        if (field[row - 1][col] === MINEMARKER) return 1;
        return 0;
    }

    function calcNE(row, col) {
        if (row === 0 || col === field[row].length) return 0;
        return field[row - 1][col + 1] === MINEMARKER ? 1 : 0;
    }

    function calcE(row, col) {
        if (col === field[row].length) return 0;
        return field[row][col + 1] === MINEMARKER ? 1 : 0;
    }

    function calcSE(row, col) {
        if (row === field.length - 1 || col === field[row].length) return 0;
        return field[row + 1][col + 1] === MINEMARKER ? 1 : 0;
    }

    function calcS(row, col) {
        if (row === field.length - 1) return 0;
        return field[row + 1][col] === MINEMARKER ? 1 : 0;
    }

    function calcSW(row, col) {
        if (row === field.length - 1 || col === 0) return 0;
        return field[row + 1][col - 1] === MINEMARKER ? 1 : 0;
    }

    function calcW(row, col) {
        if (col === 0) return 0;
        return field[row][col - 1] === MINEMARKER ? 1 : 0;
    }

    function calcNW(row, col) {
        if (row === 0 || col === 0) return 0;
        return field[row - 1][col - 1] === MINEMARKER ? 1 : 0;
    }

    function createTable() {
        //const rows = FIELDHEIGHT;
        let container = document.getElementById("tbl");
        let tbl = document.createElement('table');
        tbl.setAttribute('id', 'field');
        let tbody = document.createElement('tbody')
        for (let i = 0; i < FIELDHEIGHT; i++) {
            let tr = document.createElement('tr');
            for (let j = 0; j < FIELDHEIGHT; j++) {
                let td = document.createElement('td');
                td.setAttribute('data-row', i);
                td.setAttribute('data-col', j);
                td.setAttribute('data-hidden', 1);
                td.setAttribute('data-cell', 'cell-' + i + '-' + j);
                let textNode = i + ' - ' + j;

                if (field[i][j] == MINEMARKER) {
                    textNode = MINEMARKER;
                }
                td.appendChild(document.createTextNode(textNode));
                tr.appendChild(td);
                tbody.appendChild(tr);
            }
            tbl.appendChild(tbody);
            container.appendChild(tbl);
        }
    }

    function randomNumber() {
        const upperBound = FIELDWIDTH;
        return Math.floor(Math.random() * upperBound);
    }

</script>

<style>
    td {
        border: 1px solid red;
        padding: 1px;
        margin: 3px;
        width: 35px;
    }
</style>