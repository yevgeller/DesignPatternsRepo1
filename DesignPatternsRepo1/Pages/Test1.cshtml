@page
@model DesignPatternsRepo1.Pages.Test1Model
@{
}

@*more cleanup
figure out multiple gameovers
use map for field
counter of mines left
wrongly placed mines
*@

<div id="tbl" class="mt-5"></div>

<div class="mt-5">
    <button class="button" onclick="resetGame()" oncontextmenu="preventDefault();alert('hi')">Reset</button>
    Mines left: <span id="minesLeft"></span>
</div>


<script>
    const FIELDWIDTH = 10;
    const FIELDHEIGHT = 10;
    const MINECOUNT = 23;
    const MINEMARKER = 'X';
    let field = Array.from(Array(FIELDHEIGHT), () => new Array(FIELDWIDTH).fill('.'));
    let revealedCellsCount = 0;
    let map = new Map();
    let won = false;
    let minesLeft = 0;

    class Cell {
        constructor(row, col) {
            this.row = row;
            this.col = col;
        }
    }

    document.addEventListener("DOMContentLoaded", function () {
        resetGame();
    });

    function resetGame() {
        revealedCellsCount = 0;
        map = new Map();
        won = false;
        field = Array.from(Array(FIELDHEIGHT), () => new Array(FIELDWIDTH).fill('.'));
        createField();
        calculateMarkers();
        createTable();
        minesLeft = MINECOUNT;
        setMineCountDisplay();
        document.querySelectorAll('#field td').forEach(el => el.addEventListener('click', clickCell));
        document.querySelectorAll('#field td').forEach(el => el.addEventListener('contextmenu', toggleDanger, false));
    }

    function createField() {
        let mineCount = MINECOUNT;

        while (mineCount > 0) {
            rndRow = randomNumber();
            rndCol = randomNumber();
            if (field[rndRow][rndCol] !== MINEMARKER) {
                field[rndRow][rndCol] = MINEMARKER;
                mineCount--;
            }
        }
        console.log(field);
    }

    function calculateMarkers() {
        for (let i = 0; i < field.length; i++) {
            for (let j = 0; j < field[i].length; j++) {
                if (field[i][j] === MINEMARKER) continue;
                let marker = calcFieldMarker(i, j);
                if (marker > 0) {
                    field[i][j] = marker.toString();
                }
            }
        }
        console.log(field);
    }

    function createTable() {
        let container = document.getElementById("tbl");
        container.innerHTML = '';
        let tbl = document.createElement('table');
        tbl.setAttribute('id', 'field');
        let tbody = document.createElement('tbody')
        for (let i = 0; i < FIELDHEIGHT; i++) {
            let tr = document.createElement('tr');
            for (let j = 0; j < FIELDHEIGHT; j++) {
                let td = document.createElement('td');
                td.setAttribute('data-row', i);
                td.setAttribute('data-col', j);
                td.setAttribute('data-hidden', 1);
                td.setAttribute('data-cell', 'cell-' + i + '-' + j);
                td.classList.add('field');
                let textNode = i + ' - ' + j;

                if (field[i][j] == MINEMARKER) {
                    textNode = MINEMARKER;
                }
                //td.appendChild(document.createTextNode(textNode));
                td.appendChild(document.createTextNode('?'));
                tr.appendChild(td);
                tbody.appendChild(tr);
            }
            tbl.appendChild(tbody);
            container.appendChild(tbl);
        }
    }

    function setMineCountDisplay() {
        document.getElementById('minesLeft').innerText = minesLeft;
    }

    function clickCell(el) {
        //debugger;
        let hidden = el.currentTarget.getAttribute('data-hidden');
        if (hidden == '0') {
            return;
        }
        revealCell(el.currentTarget);
    }

    function revealCell(el) {
        let row = el.getAttribute('data-row');
        let col = el.getAttribute('data-col');
        if (!map.get(row + '-' + col)) {
            map.set(row + '-' + col, 1);
            revealedCellsCount++;
        }
        //console.log('row-col:', row + ' - ' + col);
        let data = getCellData(row, col);
        el.innerText = data;
        el.style.backgroundColor = "yellow";
        el.style.color = "black";
        el.setAttribute('data-hidden', 0);
        if (data === MINEMARKER) {
            gameOver(false);
        } else if (data === '.') {
            el.removeEventListener('contextmenu', toggleDanger, false);
            let surroundingUnrevealedCells = getSurroundingCells(row, col);
            processCells(surroundingUnrevealedCells);
        } else if (revealedCellsCount === FIELDHEIGHT * FIELDWIDTH - MINECOUNT && won === false) {
            won = true;
            gameOver(true);
        }
    }

    function getCellData(row, col) {
        //console.log('checking row:' + row + ' col: ' + col);
        console.log('cell data is ', field[row][col]);
        return field[row][col];
    }

    function getSurroundingCells(rowStr, colStr) {
        let interimResult = [];
        let row = Number(rowStr);
        let col = Number(colStr);
        let firstRow = row === 0;
        let firstCol = col === 0;
        let lastRow = row === (field.length - 1);
        let lastCol = col === (field[row].length - 1);
        let midRow = !firstRow && (row < field.length - 1);
        let midCol = !firstCol && (col < field[row].length - 1);

        if (midRow && midCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row - 1, col - 1)); //NW
        } else if (midRow && firstCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
        } else if (midRow && lastCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col - 1)); //NW
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row + 1, col)); //S
        } else if (firstRow && midCol) {
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row, col - 1)); //W
        } else if (lastRow && midCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row - 1, col - 1)); //NW
        } else if (firstRow && firstCol) { //top left
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
        } else if (firstRow && lastCol) { //top right
            interimResult.push(new Cell(row + 1, col)); //S
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row, col - 1)); //W
        } else if (lastRow && firstCol) { //bottom left
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
        } else if (lastRow && lastCol) { //bottom right
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row - 1, col - 1)); //NW
        } else {
            alert('should not be here, row: ' + row + ', col: ' + col);
        }

        let result = [];

        interimResult.forEach(x => {
            let cell = getCell(x);
            if (cell) {
                let ishidden = this.isHidden(cell);
                if (ishidden)
                    result.push(x);
            } else console.log('Cell not found with coordinates: ', x.row, x.col);
        });
        return result;
    }

    function getCell(x) {
        return document.querySelector('[data-cell="cell-' + x.row + '-' + x.col + '"]');
    }

    function processCells(cells) {
        //debugger;
        while (cells.length > 0) {
            let first = cells.shift();
            let data = getCellData(first.row, first.col);
            let cell = getCell(first);
            revealCell(cell);
            if (data === '.') {
                processCells(getSurroundingCells(first.row, first.col));
            }
        }
    }

    function isHidden(el) {
        let data = el.getAttribute('data-hidden');
        if (!data) return false;
        if (data == '1') return true;

        return false;
    }

    function setRevealed(el) {
        el.setAttribute('data-hidden', 0);
    }

    function gameOver(win) {
        console.error('game over! Refresh page to start again.');
        document.querySelectorAll('#field td').forEach(el => {
            let row = el.getAttribute('data-row');
            let col = el.getAttribute('data-col');

            let data = getCellData(row, col);

            el.removeEventListener('click', clickCell);
            el.removeEventListener('contextmenu', toggleDanger, false);
            if (data === MINEMARKER) {
                el.style.backgroundColor = (win ? "green" : "red");
                el.innerText = MINEMARKER;
            }
        });
    }

    function toggleDanger(el) {
        debugger;
        el.preventDefault();
        if (el.target.classList.contains('danger')) {
            minesLeft += 1;
            el.target.addEventListener('click', clickCell);
            el.target.classList.remove('danger');
        } else {
            minesLeft -= 1;
            el.target.removeEventListener('click', clickCell);
            el.target.classList.add('danger');
        }
        setMineCountDisplay();
        return false;
    }

    function calcFieldMarker(row, col) {
        let n = calcN(row, col);
        let ne = calcNE(row, col);
        let e = calcE(row, col);
        let se = calcSE(row, col);
        let s = calcS(row, col);
        let sw = calcSW(row, col);
        let w = calcW(row, col);
        let nw = calcNW(row, col);
        return n + ne + e + se + s + sw + w + nw;
    }

    function calcN(row, col) {
        if (row === 0) return 0;
        return field[row - 1][col] === MINEMARKER ? 1 : 0;
    }

    function calcNE(row, col) {
        if (row === 0 || col === field[row].length) return 0;
        return field[row - 1][col + 1] === MINEMARKER ? 1 : 0;
    }

    function calcE(row, col) {
        if (col === field[row].length) return 0;
        return field[row][col + 1] === MINEMARKER ? 1 : 0;
    }

    function calcSE(row, col) {
        if (row === field.length - 1 || col === field[row].length) return 0;
        return field[row + 1][col + 1] === MINEMARKER ? 1 : 0;
    }

    function calcS(row, col) {
        if (row === field.length - 1) return 0;
        return field[row + 1][col] === MINEMARKER ? 1 : 0;
    }

    function calcSW(row, col) {
        if (row === field.length - 1 || col === 0) return 0;
        return field[row + 1][col - 1] === MINEMARKER ? 1 : 0;
    }

    function calcW(row, col) {
        if (col === 0) return 0;
        return field[row][col - 1] === MINEMARKER ? 1 : 0;
    }

    function calcNW(row, col) {
        if (row === 0 || col === 0) return 0;
        return field[row - 1][col - 1] === MINEMARKER ? 1 : 0;
    }

    function randomNumber() {
        const upperBound = FIELDWIDTH;
        return Math.floor(Math.random() * upperBound);
    }

</script>

<style>
    .field {
        border: 1px solid red;
        padding: 1px;
        margin: 3px;
        width: 35px;
        text-align: center !important;
    }

    /*.revealed {
            border: 1px solid red;
            padding: 1px;
            margin: 3px;
            width: 35px;
            text-align: center;
        }*/

    .won {
        background-color: green;
    }

    .lost {
        background-color: red;
    }

    .danger {
        background-color: aqua;
        font-weight: bold;
        content: 'O';
        color: black;
    }
</style>