@page
@model DesignPatternsRepo1.Pages.Test1Model
@{
}


<div id="div1">Testing Shmesting</div>

<div id="tbl"></div>
<br />
<br />
<table>
    <tr><td>1-1</td><td>1-2</td></tr>
    <tr><td>2-1</td><td>2-2</td></tr>
</table>

<script>
    const FIELDWIDTH = 5;
    const FIELDHEIGHT = 5;
    const MINECOUNT = 7;
    const field = Array.from(Array(10), () => new Array(10).fill('.'));
    const MINEMARKER = 'X';

    let toProcess = [];

    class Cell {
        constructor(row, col) {
            this.row = row;
            this.col = col;
        }
    }

    document.addEventListener("DOMContentLoaded", function () {
        createField();
        calculateMarkers();
        createTable();
        document.querySelectorAll('#field td').forEach(el => el.addEventListener('click', clickCell));

        //document.querySelectorAll('#field td').forEach(el => el.addEventListener('click', function () {
        //    let row = el.getAttribute('data-row');
        //    let col = el.getAttribute('data-col');
        //    console.log('row-col:', row + ' - ' + col);
        //    console.log('field value:', field[row][col]);
        //    let data = field[row][col];
        //    if(data === 'X') {
        //        gameOver();
        //    }
        //    el.innerText = field[row][col];
        //}));
    });

    function clickCell(el) {
        let hidden = el.currentTarget.getAttribute('data-hidden');
        if (hidden == '0') {
            return;
        }
        revealCell(el.currentTarget);
        //let row = el.currentTarget.getAttribute('data-row');
        //let col = el.currentTarget.getAttribute('data-col');
        //let data = field[row][col];
        //if (data === 'X') {
        //    gameOver();
        //} else if (data === '.') {
        //    toProcess.push(...getSurroundingCells(row, col));
        //    console.log(toProcess);
        //}
    }

    function revealCell(el) {
        let row = el.getAttribute('data-row');
        let col = el.getAttribute('data-col');
        console.log('row-col:', row + ' - ' + col);
        let data = getCellData(row, col);
        el.innerText = data;
        el.style.backgroundColor = "yellow";
        el.style.color = "black";
        el.setAttribute('data-hidden', 0);
        if (data === 'X') {
            gameOver();
        } else if (data === '.') {
            toProcess.push(...getSurroundingCells(row, col));
            console.log(toProcess);
            processCells();
        }
    }

    function getCellData(row, col) {
        console.log('checking row:' + row + ' col: ' + col);
        return field[row][col];
    }

    function getSurroundingCells(rowStr, colStr) {
        let interimResult = [];
        let row = Number(rowStr);
        let col = Number(colStr);
        let firstRow = row === 0;
        let firstCol = col === 0;
        let lastRow = row === (field.length - 1);
        let lastCol = col === (field[row].length - 1);
        let midRow = !firstRow && (row < field.length - 1);
        let midCol = !firstCol && (col < field[row].length - 1);

        if (midRow && midCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row - 1, col - 1)); //NW
        } else if (midRow && firstCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
        } else if (midRow && lastCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col - 1)); //NW
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row + 1, col)); //S
        } else if (firstRow && midCol) {
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row, col - 1)); //W
        } else if (lastRow && midCol) {
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row - 1, col - 1)); //NW
        } else if (firstRow && firstCol) { //top left
            interimResult.push(new Cell(row, col + 1)); //E
            interimResult.push(new Cell(row + 1, col + 1)); //SE
            interimResult.push(new Cell(row + 1, col)); //S
        } else if (firstRow && lastCol) { //top right
            interimResult.push(new Cell(row + 1, col)); //S
            interimResult.push(new Cell(row + 1, col - 1)); //SW
            interimResult.push(new Cell(row, col - 1)); //W
        } else if (lastRow && firstCol) { //bottom left
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row - 1, col + 1)); //NE
            interimResult.push(new Cell(row, col + 1)); //E
        } else if (lastRow && lastCol) { //bottom right
            interimResult.push(new Cell(row - 1, col)); //N
            interimResult.push(new Cell(row, col - 1)); //W
            interimResult.push(new Cell(row - 1, col - 1)); //NW
        } else {
            alert('should not be here, row: ' + row + ', col: ' + col);
        }

        let result = [];

        interimResult.forEach(x => {
            let cell = getCell(x);
            if (cell) {
                let ishidden = this.isHidden(cell);
                let alreadyIn = alreadyInQueue(x);
                if (ishidden && !alreadyIn)
                    result.push(x);
                //else
                //    console.log('cell ' + x.row + '-' + x.col + ' is already revealed.');
                //console.log(cell);
            } else console.log('Cell not found with coordinates: ', x.row, x.col);
        });

        return result;
    }

    function getCell(x) {
        return document.querySelector('[data-cell="cell-' + x.row + '-' + x.col + '"]');
    }

    function alreadyInQueue(cell) {
        if (toProcess.some(x => x.row === cell.row && x.col === cell.col)) {
            return true;
        }
        return false;
    }

    function processCells() {
        while (toProcess.length > 0) {
            debugger;
            let first = toProcess.shift();
            let data = getCellData(first.row, first.col);
            let cell = getCell(first);
            revealCell(cell);
            if (data === '.') {
                toProcess.push(getSurroundingCells(first.row, first.col));
            }
        }
    }

    function isHidden(el) {
        let data = el.getAttribute('data-hidden');
        if (!data) return false;
        if (data == '1') return true;

        return false;
    }

    function setRevealed(el) {
        el.setAttribute('data-hidden', 0);
    }

    function gameOver() {
        alert('game over! Refresh page to start again.');
        document.querySelectorAll('#field td').forEach(el => {
            el.removeEventListener('click', clickCell);
            if (el.innerText === 'X')
                el.style.backgroundColor = "red";
        });
    }

    function createField() {
        let mineCount = MINECOUNT;

        while (mineCount > 0) {
            rndRow = randomNumber();
            rndCol = randomNumber();
            if (field[rndRow][rndCol] !== MINEMARKER) {
                field[rndRow][rndCol] = MINEMARKER;
                mineCount--;
            }
        }
        console.log(field);
    }

    function calculateMarkers() {
        for (let i = 0; i < field.length; i++) {
            for (let j = 0; j < field[i].length; j++) {
                if (field[i][j] === MINEMARKER) continue;
                let marker = calcFieldMarker(i, j);
                if (marker > 0) {
                    field[i][j] = marker.toString();
                }
            }
        }
        console.log(field);
    }

    function calcFieldMarker(row, col) {
        let n = calcN(row, col);
        let ne = calcNE(row, col);
        let e = calcE(row, col);
        let se = calcSE(row, col);
        let s = calcS(row, col);
        let sw = calcSW(row, col);
        let w = calcW(row, col);
        let nw = calcNW(row, col);
        return n + ne + e + se + s + sw + w + nw;
    }

    function calcN(row, col) {
        if (row === 0) return 0;
        if (field[row - 1][col] === MINEMARKER) return 1;
        return 0;
    }

    function calcNE(row, col) {
        if (row === 0 || col === field[row].length) return 0;
        return field[row - 1][col + 1] === MINEMARKER ? 1 : 0;
    }

    function calcE(row, col) {
        if (col === field[row].length) return 0;
        return field[row][col + 1] === MINEMARKER ? 1 : 0;
    }

    function calcSE(row, col) {
        if (row === field.length - 1 || col === field[row].length) return 0;
        return field[row + 1][col + 1] === MINEMARKER ? 1 : 0;
    }

    function calcS(row, col) {
        if (row === field.length - 1) return 0;
        return field[row + 1][col] === MINEMARKER ? 1 : 0;
    }

    function calcSW(row, col) {
        if (row === field.length - 1 || col === 0) return 0;
        return field[row + 1][col - 1] === MINEMARKER ? 1 : 0;
    }

    function calcW(row, col) {
        if (col === 0) return 0;
        return field[row][col - 1] === MINEMARKER ? 1 : 0;
    }

    function calcNW(row, col) {
        if (row === 0 || col === 0) return 0;
        return field[row - 1][col - 1] === MINEMARKER ? 1 : 0;
    }

    function createTable() {
        //const rows = FIELDHEIGHT;
        let container = document.getElementById("tbl");
        let tbl = document.createElement('table');
        tbl.setAttribute('id', 'field');
        let tbody = document.createElement('tbody')
        for (let i = 0; i < FIELDHEIGHT; i++) {
            let tr = document.createElement('tr');
            for (let j = 0; j < FIELDHEIGHT; j++) {
                let td = document.createElement('td');
                td.setAttribute('data-row', i);
                td.setAttribute('data-col', j);
                td.setAttribute('data-hidden', 1);
                td.setAttribute('data-cell', 'cell-' + i + '-' + j);
                let textNode = i + ' - ' + j;

                if (field[i][j] == MINEMARKER) {
                    textNode = MINEMARKER;
                }
                td.appendChild(document.createTextNode(textNode));
                tr.appendChild(td);
                tbody.appendChild(tr);
            }
            tbl.appendChild(tbody);
            container.appendChild(tbl);
        }
    }

    function randomNumber() {
        const upperBound = 10;
        return Math.floor(Math.random() * upperBound);
    }

</script>

<style>
    td {
        border: 1px solid red;
        padding: 1px;
        margin: 3px;
        width:35px;
    }
</style>