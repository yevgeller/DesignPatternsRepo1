@page
@model DesignPatternsRepo1.Pages.Structural.CompositeModel
@{
}

<h1 class="title is-1 is-spaced"><i class="fa-solid fa-magnifying-glass-arrow-right mr-2"></i>Composite</h1>
<h2 class="subtitle">Working with tree-like components in a uniform way regardless of whether it's a leaf or a container</h2>
<div class="content">

    <div class="block">
        This pattern is used for working with nested-container type of items. It's a uniform way to treat an object
        whether it's another container or actually an item that can do some action.
    </div>
    <div class="block">
        Here's the recipe of all that's needed to implement the pattern:
        <ol>
            <li>General class called "Component" that has basic properties and methods</li>
            <li>Class "Leaf" that accepts an identifier as a parameter (a name in the example case). This class
                can perform a basic operation that is required (just return its name in our example);
            </li>
            <li>Class "Composite" that also takes an identifier as a parameter. It also tracks a collection
                of its children leafs or composites that are assigned to this class. The class can process
                assignments/removals to that collection. The class can als return its name as its
                primary operation. The primary operation on this class also triggers the primary operation on
                each of the children in the collection.
            </li>
        </ol>
    </div>
<pre>
    <code class="language-ts">class Component {
  name: string;
  primaryOperation(depth: number): void {}
  add(component: Component): void {}
  remove(component: Component): void {}

  constructor(name: string) {
    this.name = name;
  }
}

class Leaf extends Component {
  name: string;
  constructor(name: string) {
    super(name);
    this.name = name;
  }
  primaryOperation(depth: number): void {
    console.log(Array(depth).join("-") + this.name);
  }
  add(component: Component): void {
    throw new Error("Method not implemented.");
  }
  remove(component: Component): void {
    throw new Error("Method not implemented.");
  }
}

class Composite extends Component {
  name: string;
  components: Component[];
  constructor(name: string) {
    super(name);
    this.name = name;
    this.components = [];
  }
  primaryOperation(depth: number): void {
    console.log(Array(depth).join("-") + this.name);
    this.components.forEach((x) => x.primaryOperation(depth + 2));
  }
  add(component: Component): void {
    this.components.push(component);
  }
  remove(component: Component): void {
    this.components = this.components.filter((x) => x.name !== component.name);
  }
}
  </code>
  </pre>
    <div class="block">
       
    </div>
</div>

<bottom-nav next-pointer-word="Next"
            next-icon1="fa-solid fa-circle-question"
            next-icon3="fa-solid fa-arrow-right"
            next-link="Index"
            next-name="TBA"></bottom-nav>
<script>hljs.highlightAll();</script>