@page
@model DesignPatternsRepo1.Pages.Structural.BridgeModel
@{
}

<h1 class="title is-1 is-spaced"><i class="fa-solid fa-left-right mr-2"></i>Bridge</h1>
<h2 class="subtitle">Decoupling Abstraction from Implementation</h2>
<h3 class="subtitle is-3">Problem</h3>
<div class="content">
    <div class="block">
        Imagine you are working on an interface for buyers to spec out new vehicles and it is time to work on the Interior configuration.
        For the sake of simplicity, customers can only pick one of two interior colors (black or beige) and one of two materials (cloth or leather).

        Then the code for each of the interiors would look something like that:
    </div>
<pre>
<code class="language-ts">class CarInterior {
    model: string;
    interiorColor: string;
    interiorMaterial: string;
    constructor(model: string) {
      this.model = model;
    }
    getSummary = () =>
      console.log(
        `Model: ${this.model}, ${this.interiorColor} ${this.interiorMaterial} interior.`
      );
  }

  class BlackLeatherInterior extends CarInterior {
    constructor(model: string) {
      super(model);
      this.model = model;
      this.interiorColor = "black";
      this.interiorMaterial = "leather";
    }
  }
  class BeigeLeatherInterior extends CarInterior {
    constructor(model: string) {
      super(model);
      this.model = model;
      this.interiorColor = "beige";
      this.interiorMaterial = "leather";
    }
  }
  class BlackClothInterior extends CarInterior {
    constructor(model: string) {
      super(model);
      this.model = model;
      this.interiorColor = "black";
      this.interiorMaterial = "cloth";
    }
  }
  class BeigeClothInterior extends CarInterior {
    constructor(model: string) {
      super(model);
      this.model = model;
      this.interiorColor = "beige";
      this.interiorMaterial = "cloth";
    }
  }

  </code>
  </pre>
    <div class="block">
        This testing code returns this:
    </div>
<pre>
<code class="language-ts">
  let bl = new BlackLeatherInterior("A");
  let rc = new BeigeClothInterior("B");
  let bc = new BlackClothInterior("C");

  bl.getSummary();
  rc.getSummary();
  bc.getSummary();

  //output:
  Model: A, black leather interior.
  Model: B, beige cloth interior.
  Model: C, black cloth interior.
  </code>
  </pre>
    <div class="block">
        And then you got a word that another interior color may be available. Also, it has to be customizable for different car models.
        Creating a class for each combination of resources will quickly become unwieldy. There has to be a better way!
    </div>
</div>
<h3 class="subtitle is-3">Solution -- applying Bridge pattern</h3>
<div class="content">
    <div class="block">
        Bridge pattern is applicable when you can separate a component into parts reducing coupling. One of the parts
        is deemed as the <em>abstraction"</em>" and it will be sort of a foundation on which everything else is built. Every other
        variable aspect is deemed <em>"implementation"</em> and the two can vary independently. It is almost like making a bead
        bracelet: the string is the abstraction, it holds everything together, but it does not care what beads you put on,
        it will still be a bead bracelet.
    </div>
    <div class="block">
        To rework the previous example, let's deem the Interior class as the Abstraction. Any vehicle has an interior,
        and everything else will be considered "implementation" and vary as needed.
    </div>

<pre>
    <code class="language-ts">
 class CarInterior {
    interiorColor: string;
    interiorMaterial: string;
    model: string;
    constructor(
      model: string,
      color: InteriorColor,
      material: InteriorMaterial
    ) {
      this.model = model;
      this.interiorColor = color.interiorColor;
      this.interiorMaterial = material.interiorMaterial;
    }

    getSummary = () =>
      console.log(
        `Model: ${this.model}, ${this.interiorColor} ${this.interiorMaterial} interior.`
      );
  }
</code>
  </pre>
    <div class="block">
        Let's specify the InteriorColor and InteriorMaterial interfaces that will help color and material implementations vary:
    </div>
<pre>
    <code class="language-ts">
  interface InteriorColor {
    interiorColor: string;
  }

  interface InteriorMaterial {
    interiorMaterial: string;
  }</code></pre>
    <div class="block">
        Text here
    </div>

    <div class="block">
        Next, separate classes that implement those interfaces and focus on only one aspect:
    </div>
<pre>
<code class="language-ts">class BlackInterior implements InteriorColor {
    interiorColor: string;
    constructor() {
      this.interiorColor = "black";
    }
  }
  class BeigeInterior implements InteriorColor {
    interiorColor: string;
    constructor() {
      this.interiorColor = "beige";
    }
  }

  class LeatherInterior implements InteriorMaterial {
    constructor() {
      this.interiorMaterial = "leather";
    }
    interiorMaterial: string;
  }

  class ClothInterior implements InteriorMaterial {
    interiorMaterial: string;
    constructor() {
      this.interiorMaterial = "cloth";
    }
  }</code></pre>
    <div class="block">
        Text here
    </div>
</div>

<div class="content">
    <div class="block">
        Ultimately, we went from a flat, tightly coupled hierarchy like this:
        <br />

    </div>
    <div class="columns is-centered">
        <div class="image">
            <img src="~/images/Bridge-bad.drawio.png" />
        </div>
    </div>
    <div class="block">
        to a more decoupled hierarchy like this:

    </div>

    <div class="columns is-centered">
        <div class="image">
            <img src="~/images/Bridge-good.drawio.png" />
        </div>
    </div>
</div>
<bottom-nav next-pointer-word="Next"
            next-icon1="fa-solid fa-circle-question"
            next-icon3="fa-solid fa-arrow-right"
            next-link="Index"
            next-name="TBA"></bottom-nav>
<script>hljs.highlightAll();</script>

Fix link from Adapter to Bridge

Think about putting whole menu on the bottom, disabling link to the one that the page is currently on

новую функцию и постоянно заменяют
<div class="block">
    Text here
</div>
<div class="block">
    Text here
</div>

<pre>
<code class="language-ts">
  </code>
  </pre>
<pre>
<code class="language-ts">
  </code>
  </pre>