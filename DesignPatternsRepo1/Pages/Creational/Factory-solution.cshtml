@page
@model DesignPatternsRepo1.Pages.Creational.Factory_solutionModel
@{
}

<script>hljs.highlightAll();</script>

<h1 class="title is-1 is-spaced"><i class="fa-solid fa-industry"></i>Factory &mdash; Solution</h1>
<h2 class="subtitle">A pattern used to differentiate between items that have something in common</h2>
<div class="content">

    <p>First, let's extract something in common from all elements so that we can operate on an abstraction and not a concrete entity</p>
<pre><code class="language-ts">
  interface Present {
    whatIsIt(): string;
    play(): string;
  }

  </code></pre>
    <p>Then let's define concrete classes and ensure they implement the common interface:</p>
<pre><code class="language-ts">
  class ToyCar implements Present {
    whatIsIt(): string {
      return "This is a toy car";
    }
    play(): string {
      return "vroom!!";
    }
  }

  class ToyBoat implements Present {
    play(): string {
      return "Off we go!";
    }
    whatIsIt(): string {
      return "This is a toy boat";
    }
  }

  class BagOfCoal implements Present {
    play(): string {
      return "You now have a dirty face!";
    }
    whatIsIt(): string {
      return "Bag of coal";
    }
  }
    </code></pre>
    <p>Next, the Creator class, this is where the magic of extensibility happens:</p>
<pre><code class="language-ts">
  enum ToyType {
    car,
    boat,
    coal,
  }
  //Creator class
  class ToyFactory {
    makeAToy(typeOfToy: ToyType): Present {
      switch (typeOfToy) {
        case ToyType.boat: {
          return new ToyBoat();
        }
        case ToyType.car: {
          return new ToyCar();
        }
        case ToyType.coal: {
          return new BagOfCoal();
        }
      }
    }
  }

  </code></pre>
    <p>Finally, the wire-up:</p>
<pre><code class="language-ts">

  class ElvesFactory {
    toyFactory: ToyFactory;

    constructor(toyFactory: ToyFactory) {
      this.toyFactory = toyFactory;
    }

    makeToys(order: ToyType[]) {
      order.forEach((x) => {
        let toy = this.toyFactory.makeAToy(x);
        console.log(toy.whatIsIt());
        console.log(toy.play());
      });
    }
  }
  </code></pre>
    <p>Test:</p>
<pre><code class="language-ts">

  //check:
  let tf = new ToyFactory();
  let toyProductionFacility = new ElvesFactory(tf);
  let order = new Array(
    ToyType.boat,
    ToyType.car,
    ToyType.boat,
    ToyType.car,
    ToyType.coal,
    ToyType.car
  );
  toyProductionFacility.makeToys(order);

  //output:
    This is a toy boat
    Off we go!

    This is a toy car
    vroom!!

    This is a toy boat
    Off we go!

    This is a toy car
    vroom!!

    Bag of coal
    You now have a dirty face!

    This is a toy car
    vroom!!
  </code>
</pre>
    <div class="block">
        If elves learn to make more toys, there will need to be a class created for that toy that implements the Present interface, add a value to the enum,
        and then a condition to create that type of toy into the creator class.
    </div>
</div>
<div class="columns">
    <div class="column is-2">
        <a class="navbar-item" asp-area="" asp-page="/Index">
            <i class="fa-solid fa-house-user fa-2x mr-1"></i>Back
        </a>
    </div><div class="column is-3">
        <a class="navbar-item" asp-area="" asp-page="/Creational/Abstract-problem">
            <i class="fa-solid fa-cube fa-2x mr-1"></i><i class="fa-solid fa-industry fa-2x mr-2"></i>
            Next: Abstract Factory
        </a>
    </div>
</div>
<bottom-nav 
next-pointer-word="Next"
next-icon1="fa-solid fa-cube" 
next-icon2="fa-solid fa-industry" 
next-icon3="fa-solid fa-arrow-right"
next-link="Creational|Abstract-problem" 
next-name="Abstract Factory"></bottom-nav>