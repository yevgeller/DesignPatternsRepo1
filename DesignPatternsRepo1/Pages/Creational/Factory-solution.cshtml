@page
@model DesignPatternsRepo1.Pages.Creational.Factory_solutionModel
@{
}

<script>hljs.highlightAll();</script>

<h1 class="title is-1 is-spaced">Factory &mdash; Solution</h1>
<h2 class="subtitle">A pattern used to differentiate between items that have something in common</h2>


<p>First, let's extract something in common from all elements so that we can operate on an abstraction and not a concrete entity</p>
<pre><code class="language-ts">
    interface Present {
    whatIsIt(): string;
  }
  </code></pre>
  <p>Then let's define concrete classes and ensure they implement the common interface:</p>
  <pre><code class="language-ts">
  class ToyCar implements Present {
    whatIsIt(): string {
      return "This is a toy car";
    }
  }

  class ToyBoat implements Present {
    whatIsIt(): string {
      return "This is a toy boat";
    }
  }

  class BagOfCoal implements Present {
    whatIsIt(): string {
      return "This kid has been naughty";
    }
  }
    </code></pre>
    <p>Next, the Creator class, this is where the magic of extensibility happens:</p>
    <pre><code class="language-ts">
  enum ToyType {
    car,
    boat,
    coal,
  }
    //Creator class
  class ToyFactory {
    makeAToy(typeOfToy: ToyType): Present {
      switch (typeOfToy) {
        case ToyType.boat: {
          return new ToyBoat();
        }
        case ToyType.car: {
          return new ToyCar();
        }
        case ToyType.coal: {
          return new BagOfCoal();
        }
      }
    }
  }

  </code></pre>
    <p>Finally, the wire-up:</p>
    <pre><code class="language-ts">
  
  class ElvesFactory {
    toyFactory: ToyFactory;

    constructor(toyFactory: ToyFactory) {
      this.toyFactory = toyFactory;
    }

    makeToys(order: ToyType[]) {
      order.forEach((x) => {
        let toy = this.toyFactory.makeAToy(x);
        console.log(toy.whatIsIt());
      });
    }
  }
  </code></pre>
    <p>Test:</p>
    <pre><code class="language-ts">
  
  //check:
  let tf = new ToyFactory();
  let toyProductionFacility = new ElvesFactory(tf);
  let order = new Array(
    ToyType.boat,
    ToyType.car,
    ToyType.boat,
    ToyType.car,
    ToyType.coal,
    ToyType.car
  );
  toyProductionFacility.makeToys(order);

  //output:
  This is a toy boat
  This is a toy car 
  This is a toy boat
  This is a toy car 
  This kid has been naughty
  This is a toy car
  </code>
</pre>
<p>If elves learn to make more toys, there will need to be a class created for that toy that implements the Present interface, add a value to the enum,
    and then a condition to create that type of toy into the creator class.
</p>
<br />
<br />
<br />
<br />
<br />